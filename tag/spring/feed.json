{
    "version": "https://jsonfeed.org/version/1",
    "title": "melt • All posts by \"spring\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/Spring%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7/",
            "url": "http://example.com/Spring%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7/",
            "title": "Spring中事务属性",
            "date_published": "2022-08-28T15:13:37.401Z",
            "content_html": "<h2 id=\"事务属性\"><a class=\"markdownIt-Anchor\" href=\"#事务属性\">#</a> 事务属性</h2>\n<blockquote>\n<p>种类：传播行为，隔离级别，只读，事务超时</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"传播行为\"><a class=\"markdownIt-Anchor\" href=\"#传播行为\">#</a> 传播行为</h2>\n<blockquote>\n<p><em>定义了被调用方法的事务边界</em></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>传播行为</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PROPAGATION_MANDATORY</td>\n<td>一定要有事务，没有事务就抛出异常</td>\n</tr>\n<tr>\n<td>PROPAGATION_NESTED</td>\n<td>表示如果当前事务存在，则方法应该运行在一个嵌套事务中。</td>\n</tr>\n<tr>\n<td>PROPAGATION_NEVER</td>\n<td>表示方法不能运行在一个事务中，否则抛出异常</td>\n</tr>\n<tr>\n<td>PROPAGATION_NOT_SUPPORTED</td>\n<td>不支持事物，如果存在事物就挂起</td>\n</tr>\n<tr>\n<td>PROPAGATION_REQUIRED</td>\n<td>表示当前方法必须运行在一个事务中，如果当前存在一个事务，那么该方法运行在这个事务中，否则，将创建一个新的事务</td>\n</tr>\n<tr>\n<td>PROPAGATION_REQUIRES_NEW</td>\n<td>表示当前方法必须运行在自己的事务中，如果当前存在一个事务，那么这个事务将在该方法运行期间被挂起</td>\n</tr>\n<tr>\n<td>PROPAGATION_SUPPORTS</td>\n<td>表示当前方法不需要运行在一个是事务中，但如果有一个事务已经存在，该方法也可以运行在这个事务中</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"隔离级别\"><a class=\"markdownIt-Anchor\" href=\"#隔离级别\">#</a> 隔离级别</h2>\n<blockquote>\n<p>在操作数据时可能带来 3 个副作用：分别是脏读、不可重复读、幻读。</p>\n<p>SQL 语句中定义了 4 种隔离级别，分别是未提交读、已提交读、可重复读、可序列化。</p>\n<p>而在 spring 事务中提供了 5 种隔离级别来对应在 SQL 中定义的 4 种隔离级别，</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ISOLATION_DEFAULT</td>\n<td>使用后端数据库默认的隔离级别</td>\n</tr>\n<tr>\n<td>ISOLATION_READ_UNCOMMITTED</td>\n<td>允许读取未提交的数据（对应未提交读），可能导致脏读、不可重复读、幻读</td>\n</tr>\n<tr>\n<td>ISOLATION_READ_COMMITTED</td>\n<td>允许在一个事务中读取另一个已经提交的事务中的数据（对应已提交读）。可以避免脏读，但是无法避免不可重复读和幻读</td>\n</tr>\n<tr>\n<td>ISOLATION_REPEATABLE_READ</td>\n<td>一个事务不可能更新由另一个事务修改但尚未提交（回滚）的数据（对应可重复读）。可以避免脏读和不可重复读，但无法避免幻读</td>\n</tr>\n<tr>\n<td>ISOLATION_SERIALIZABLE</td>\n<td>这种隔离级别是所有的事务都在一个执行队列中，依次顺序执行，而不是并行（对应可序列化）。可以避免脏读、不可重复读、幻读。但是这种隔离级别效率很低，因此，除非必须，否则不建议使用。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"只读\"><a class=\"markdownIt-Anchor\" href=\"#只读\">#</a> 只读</h2>\n<p>如果在一个事务中所有关于数据库的操作都是只读的，也就是说，这些操作只读取数据库中的数据，而并不更新数据，那么应将事务设为只读模式（ READ_ONLY_MARKER ） , 这样更有利于数据库进行优化 。</p>\n<p>因为只读的优化措施是事务启动后由数据库实施的，因此，只有将那些具有可能启动新事务的传播行为 (PROPAGATION_NESTED 、 PROPAGATION_REQUIRED 、 PROPAGATION_REQUIRED_NEW) 的方法的事务标记成只读才有意义。</p>\n<p>如果使用 Hibernate 作为持久化机制，那么将事务标记为只读后，会将 Hibernate 的 flush 模式设置为 FULSH_NEVER, 以告诉 Hibernate 避免和数据库之间进行不必要的同步，并将所有更新延迟到事务结束。</p>\n<h2 id=\"事务延时\"><a class=\"markdownIt-Anchor\" href=\"#事务延时\">#</a> 事务延时</h2>\n<p>如果一个事务长时间运行，这时为了尽量避免浪费系统资源，应为这个事务设置一个有效时间，使其等待数秒后自动回滚。与设置 “只读” 属性一样，事务有效属性也需要给那些具有可能启动新事物的传播行为的方法的事务标记成只读才有意义。</p>\n",
            "tags": [
                "Spring"
            ]
        }
    ]
}